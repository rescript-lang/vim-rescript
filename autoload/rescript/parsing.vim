" Links to the reference implementation:
" - https://github.com/rescript-lang/rescript-vscode/blob/master/server/src/utils.ts
" - https://github.com/rescript-lang/rescript-vscode/blob/master/CONTRIBUTING.md
"


" Parses all syntax errors from the output of the ReScript syntax parser
"
" {lines} is a list of lines (usually generated by systemlist)
" Every parsed filepath will be replaced with {filename} (useful for replacing
" temporary filenames)
"
" It returns a list of dicts containing the error information. Those dicts
" follow the same format as documented in |setqflist()|
function! rescript#parsing#ParseSyntaxParserOutput(lines, filename)
  let l:errors = []

  let l:i = 0

  let l:filedata = []
  let text = ""

  " used for file preview: 2 spaces = start of error message
  let spaces = 0

  " syntax_error, filedata, file_preview , error_msg
  let mode = "syntax_error"

  let l:last = len(a:lines) - 1

  while l:i < len(a:lines)
    let line = a:lines[l:i]

    if mode ==? "syntax_error"
      if trim(line) ==# "Syntax error!"
        let mode = "filedata"
        let text = ""
      endif
    elseif mode ==? "filedata"
      let l:tokens = matchlist(line, '.*\.res\s*:*\([0-9]\+\):\([0-9]\+\).*')
      if !empty(l:tokens)
        let l:filedata = l:tokens
        let mode = "file_preview"
      endif 
    elseif mode ==? "file_preview"
      if trim(line) == ""
        let spaces += 1
      endif
      if spaces == 2
        let mode = "error_msg"
        let spaces = 0
      endif
    elseif mode ==? "error_msg"
      if l:i == l:last || trim(a:lines[l:i+1]) ==# "Syntax error!"
        if !empty(l:filedata)
          call add(l:errors, {"filename": a:filename,
                \"bufnr": bufnr(a:filename),
                \"lnum": l:filedata[1],
                \"col": l:filedata[2],
                \"type": "E",
                \"text": text})
          let l:filedata = []
        endif
        let text = ""
        let mode = "syntax_error"
      else
        let str = substitute(line, '^\s*\(.\{-}\)\s*$', '\1', '')
        if str != ""
          if text == ""
            let text = str
          else
            let text = text . " " . str
          endif
        endif
      endif
    endif
    let l:i += 1
  endwhile
  return l:errors
endfunction



" Parses all syntax errors from the output of the ReScript compiler /
" compiler.log
"
" {output} is a list of lines (usually generated by systemlist)
" Every parsed filepath will be replaced with {filename} (useful for replacing
" temporary filenames)
"
" It returns a list of dicts containing the error information. Those dicts
" follow the same format as documented in |setqflist()|
function! rescript#parsing#ParseCompilerErrorOutput(lines)
  let ret = []

  let l:i = 0

  " warning_number > -1 means it is a warning
  let item = {
        \'filedata': [],
        \'warning_number': -1,
        \'preview': [],
        \'text': ""}

  " used for file preview: 2 spaces = start of error message
  let spaces = 0

  " header, filedata, file_preview , error_msg
  let mode = "header"

  let l:last = len(a:lines) - 1

  while l:i < len(a:lines)
    let line = a:lines[l:i]

    if mode ==? "header"
      let trimmed = trim(line)

      if trimmed ==# "We've found a bug for you!"
        let mode = "filedata"
        let item = {
              \'filedata': [],
              \'warning_number': -1,
              \'preview': [],
              \'text': ""}
      else
        let l:tokens = matchlist(line, 'Warning number \([0-9]\+\).*')

        if !empty(l:tokens)
          let mode = "filedata"
          let item = {
                \'filedata': [],
                \'warning_number': l:tokens[1],
                \'preview': [],
                \'text': ""}
        endif
      endif
    elseif mode ==? "filedata"
      let l:tokens = matchlist(line, '\s*\(.*\.res\)\s*:*\([0-9]\+\):\([0-9]\+\).*')
      if !empty(l:tokens)
        let item.filedata = l:tokens
        let mode = "file_preview"
      endif 
    elseif mode ==? "file_preview"
      if trim(line) == ""
        let spaces += 1
      else
        let item.preview = add(item.preview, line)
      endif
      if spaces == 2
        let mode = "error_msg"
        let spaces = 0
      endif
    elseif mode ==? "error_msg"
      let trimmed = trim(get(a:lines, l:i+1, ""))

      if l:i == l:last 
            \ || trimmed ==# "We've found a bug for you!"
            \ || matchstr(trimmed, "Warning number [0-9]\+")
        if !empty(item.filedata)
          let l:type = item.warning_number > -1 ? "W" : "E"
          let text = item.warning_number > -1 ? 
                \"(Warning " . item.warning_number . ") " . item.text
                \: item.text
          call add(ret, {"filename": item.filedata[1],
                \"bufnr": item.filedata[1],
                \"lnum": item.filedata[2],
                \"col": item.filedata[3],
                \"type": l:type,
                \"text": text})
          let l:filedata = []
        endif
        let mode = "header"
      else
        let str = substitute(line, '^\s*\(.\{-}\)\s*$', '\1', '')
        let text = item.text
        if str != ""
          let text = text == "" ? str : text . " " . str
        endif
        let item.text = text
      endif

    endif
    let l:i += 1

  endwhile
  return ret
endfunction

" Parses {lines} of strings read from a .compiler.log file and returns a list
" of parsed lines (list of lists of strings) that were enclosed by START /
" DONE markers
function! rescript#parsing#ParseCompilerLogEntries(lines)
  let ret = []

  " start, collect
  let mode = "start"

  let i = 0

  let content = []

  while i < len(a:lines)
    let line = a:lines[i] 

    if mode ==? "start"
      if matchstr(line, '#Start') != ""
        let mode = "collect"
        let content = []
      endif
    elseif mode ==? "collect"
      if matchstr(line, '#Done') != ""
        let mode = "start"
        let ret = add(ret, content)
      else
        let content = add(content, line)
      endif
    endif
    let i = i + 1
  endwhile

  return ret

endfunction
